# This Creates the dataset, given the resolution and the matrix.#%% Load the required librariesimport sysimport os    dir_path = os.path.dirname(os.path.realpath(__file__))sys.path.insert(1, dir_path+'/../lib/')import numpy as npimport tensorflow as tfimport scipy.sparse as sparsefrom numpy.linalg import normimport timeimport argparseimport conjugate_gradient as cg#import pressure_laplacian as plimport helper_functions as hf#this makes sure that we are on cpuos.environ["CUDA_VISIBLE_DEVICES"]= ''#%% Get Arguments from parserparser = argparse.ArgumentParser()parser.add_argument("-N", "--resolution", type=int, choices=[64, 128, 256, 384],                    help="N or resolution of test", default = 128)parser.add_argument("--number_of_ritz_vectors", type=int,                    help="number of ritz vectors to be used as the base in the dataset", default=10000)args = parser.parse_args()#%%N = args.resolutionnum_ritz_vectors = args.number_of_ritz_vectors#%% Load the matrix AA_file_name = dataset_path + "/test_matrices_and_vectors/N"+str(N)+"/"+example_name + "/matrixA_"+str(0)+".bin"  #Change this one tho origional matrixA = hf.readA_sparse(N, A_file_name,'f')CG = cg.ConjugateGradientSparse(A)rand_vec_x = np.random.normal(0,1, [N**3])rand_vec = A.dot(rand_vec_x)#this could be the original name#name_sparse_matrix = project_folder_general + "data/output3d"+str(dim)+"_new_tgsl_rotating_fluid/matrixA_"+str(1)+".bin"   #%% Creating Lanczos Vectors:W, diagonal, sub_diagonal = CG.lanczos_iteration_with_normalization_correction(rand_vec, num_ritz_vectors) #this can be loaded directly from c++ output#W, diagonal, sub_diagonal = CG.lanczos_iteration(rand_vec, num_ritz_vectors, 1.0e-12) //Without ortogonalization#%%"""print("Loading Lanczos Vectors")W = np.zeros([num_ritz_vectors,dim2])for i in range(num_ritz_vectors):    if i%1000==0:        print(i," of the ritz vectors are loaded")    lv_filename = project_data_folder3+"lanczos_vectors_3D_N"+str(dim)+"/"+str(i)+".bin"    W[i] = hf.load_vector(lv_filename)diagonal = np.zeros([num_ritz_vectors])sub_diagonal = np.zeros([num_ritz_vectors-1])for i in range(num_ritz_vectors-1):    Av = A_sparse.dot(W[i])    diagonal[i] = np.dot(W[i],Av)    sub_diagonal[i] = np.dot(Av,W[i+1])    Av = A_sparse.dot(W[num_ritz_vectors-1])diagonal[num_ritz_vectors-1] = np.dot(W[num_ritz_vectors-1],Av)"""#%% Create the tridiagonal matrix from diagonal and subdiagonal entriestri_diag = np.zeros([num_ritz_vectors,num_ritz_vectors])for i in range(1,num_ritz_vectors-1):    tri_diag[i,i] = diagonal[i]    tri_diag[i,i+1] = sub_diagonal[i]    tri_diag[i,i-1]= sub_diagonal[i-1]tri_diag[0,0]=diagonal[0]tri_diag[0,1]=sub_diagonal[0]tri_diag[num_ritz_vectors-1,num_ritz_vectors-1]=diagonal[num_ritz_vectors-1]tri_diag[num_ritz_vectors-1,num_ritz_vectors-2]=sub_diagonal[num_ritz_vectors-2]#%% Calculating eigenvectors of the tridiagonal matrixprint("Calculating eigenvectors of the tridiagonal matrix")eigvals, Q0 = np.linalg.eigh(tri_diag)eigvals = np.real(eigvals)Q0 = np.real(Q0)#%%#ritz_vectors = np.zeros(W.shape)ritz_vectors = np.matmul(W.transpose(),Q0).transpose()